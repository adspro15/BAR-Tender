/*++

Module Name:

device.c - Device handling events for example driver.

Abstract:

This file contains the device entry points and callbacks.

Environment:

User-mode Driver Framework 2

--*/

#include "driver.h"
#include "device.tmh"
#include <WinUser.h>
#include <Wdfinterrupt.h>
#include "MsgInterface.h"

BOOLEAN
OnInterruptIsr(
	_In_  WDFINTERRUPT FxInterrupt,
	_In_  ULONG        MessageID
)
/*++

Routine Description:
This routine responds to interrupts generated by the H/W.
It then waits indefinitely for the user to signal that
the interrupt has been acknowledged, allowing the ISR to
return. This ISR is called at PASSIVE_LEVEL.
Arguments:

Interrupt - a handle to a framework interrupt object
MessageID - message number identifying the device's
hardware interrupt message (if using MSI)
Return Value:
TRUE if interrupt recognized.
--*/
{
	UNREFERENCED_PARAMETER(MessageID);
	WDFDEVICE device;
	PDEVICE_CONTEXT deviceContext;

	device = WdfInterruptGetDevice(FxInterrupt);
	deviceContext = DeviceGetContext(device);
	ProcessIrq(); // Handle IRQ at the MsgProccessor
	return TRUE;
}

NTSTATUS
BARTenderEvtDevicePrepareHardware(
	_In_ WDFDEVICE Device,
	_In_ WDFCMRESLIST ResourcesRaw,
	_In_ WDFCMRESLIST ResourcesTranslated
)
{
	NTSTATUS status = STATUS_SUCCESS;
	ULONG i;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
	PDEVICE_CONTEXT deviceContext = DeviceGetContext(Device);
	ULONG64 addr = 0;
	WDF_INTERRUPT_CONFIG interruptConfig;


	PAGED_CODE();

	for (i = 0; i < WdfCmResourceListGetCount(ResourcesTranslated); i++) {
		descriptor = WdfCmResourceListGetDescriptor(ResourcesTranslated, i);
		if ((descriptor->Type == CmResourceTypeMemory) && (descriptor->u.Memory.Length == 0x1000000))
		{
			WdfDeviceMapIoSpace(Device,
				descriptor->u.Memory.Start,
				descriptor->u.Memory.Length,
				MmNonCached,
				&deviceContext->paddr);
			deviceContext->PortCount = descriptor->u.Memory.Length;
			deviceContext->PortWasMapped = TRUE;

			addr = (ULONG64)deviceContext->paddr;
		}

		if (descriptor->Type == CmResourceTypeInterrupt)
		{
			WDF_INTERRUPT_CONFIG_INIT(
				&interruptConfig,
				OnInterruptIsr,
				NULL);
			interruptConfig.PassiveHandling = TRUE;
			interruptConfig.InterruptTranslated = WdfCmResourceListGetDescriptor(
				ResourcesTranslated,
				i);
			interruptConfig.InterruptRaw = WdfCmResourceListGetDescriptor(
				ResourcesRaw,
				i);

			status = WdfInterruptCreate(
				Device,
				&interruptConfig,
				WDF_NO_OBJECT_ATTRIBUTES,
				&deviceContext->Interrupt);
		}
	}
	CreateMsgProc(deviceContext);
	return status;
}

NTSTATUS
BARTenderEvtDeviceReleaseHardware(
	_In_ WDFDEVICE Device,
	_In_ WDFCMRESLIST ResourcesTranslated
) {
	NTSTATUS status = STATUS_SUCCESS;
	PDEVICE_CONTEXT deviceContext;
	UNREFERENCED_PARAMETER(Device);
	UNREFERENCED_PARAMETER(ResourcesTranslated);
	PAGED_CODE();
	deviceContext = DeviceGetContext(Device);
	if (deviceContext->PortWasMapped != FALSE) {
		WdfDeviceUnmapIoSpace(Device,
			deviceContext->paddr,
			deviceContext->PortCount
		);
	}
	if (deviceContext->Interrupt != NULL)
	{
		WdfObjectDelete(deviceContext->Interrupt);
	}
	DestroyMsgProc();
	return status;
}


NTSTATUS
BARTenderCreateDevice(
	_Inout_ PWDFDEVICE_INIT DeviceInit
)
/*++

Routine Description:

Worker routine called to create a device and its software resources.

Arguments:

DeviceInit - Pointer to an opaque init structure. Memory for this
structure will be freed by the framework when the WdfDeviceCreate
succeeds. So don't access the structure after that point.

Return Value:

NTSTATUS

--*/
{
	WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;
	WDF_OBJECT_ATTRIBUTES deviceAttributes;
	PDEVICE_CONTEXT deviceContext;
	WDFDEVICE device;
	NTSTATUS status;

	WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);

	pnpPowerCallbacks.EvtDevicePrepareHardware = BARTenderEvtDevicePrepareHardware;
	pnpPowerCallbacks.EvtDeviceReleaseHardware = BARTenderEvtDeviceReleaseHardware;

	WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

	WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

	status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

	if (NT_SUCCESS(status)) {
		//
		// Get a pointer to the device context structure that we just associated
		// with the device object. We define this structure in the device.h
		// header file. DeviceGetContext is an inline function generated by
		// using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
		// This function will do the type checking and return the device context.
		// If you pass a wrong object handle it will return NULL and assert if
		// run under framework verifier mode.
		//
		deviceContext = DeviceGetContext(device);
		deviceContext->Device = device;
		//
		// Create a device interface so that applications can find and talk
		// to us.
		//
		status = WdfDeviceCreateDeviceInterface(
			device,
			&GUID_DEVINTERFACE_BARTender,
			NULL // ReferenceString
		);

		if (NT_SUCCESS(status)) {
			//
			// Initialize the I/O Package and any Queues
			//
			status = BARTenderQueueInitialize(device);
		}
	}

	return status;
}
